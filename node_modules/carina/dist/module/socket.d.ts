/// <reference types="node" />
import { ReconnectionPolicy } from './reconnection';
import { EventEmitter } from 'events';
import { Packet } from './packets';
/**
 * The GzipDetector is used to determine whether packets should be compressed
 * before sending to Constellation.
 */
export interface GzipDetector {
    /**
     * shouldZip returns true if the packet, encoded as a string, should
     * be gzipped before sending to Constellation.
     * @param {string} packet `raw` encoded as a string
     * @param {any}    raw    the JSON-serializable object to be sent
     */
    shouldZip(packet: string, raw: any): boolean;
}
/**
 * SizeThresholdGzipDetector is a GzipDetector which zips all packets longer
 * than a certain number of bytes.
 */
export declare class SizeThresholdGzipDetector implements GzipDetector {
    private threshold;
    constructor(threshold: number);
    shouldZip(packet: string): boolean;
}
/**
 * Transform is a middleware used to convert incoming and outgoing packets.
 */
export interface Transform {
    /**
     * Called when we send a data packet, transforms it if necessary.
     */
    outgoing(data: string, raw: any): string | ArrayBuffer;
    /**
     * Called when a data packet is received from Constellation.
     */
    incoming(data: string | ArrayBuffer): string;
}
/**
 * GzipTransform zips incoming and outgoing messages.
 */
export declare class GzipTransform implements Transform {
    private readonly detector;
    constructor(detector: GzipDetector);
    outgoing(data: string, raw: any): string | ArrayBuffer;
    incoming(data: string | ArrayBuffer): string;
}
/**
 * SocketOptions are passed to the
 */
export interface SocketOptions {
    queryString?: object;
    isBot: boolean;
    userAgent: string;
    reconnectionPolicy: ReconnectionPolicy;
    autoReconnect: boolean;
    url: string;
    gzip?: GzipDetector;
    transform: Transform;
    jwt?: string;
    authToken?: string;
    replyTimeout: number;
    pingInterval: number;
    maxEventListeners: number;
}
/**
 * State is used to record the status of the websocket connection.
 */
export declare enum State {
    Idle = 1,
    Connecting = 2,
    Connected = 3,
    Closing = 4,
    Reconnecting = 5,
    Refreshing = 6,
}
/**
 * The ConstellationSocket provides a somewhat low-level RPC framework for
 * interacting with Constellation over a websocket. It also provides
 * reconnection logic.
 */
export declare class ConstellationSocket extends EventEmitter {
    static WebSocket: any;
    private reconnectTimeout;
    private pingTimeout;
    private options;
    private state;
    private socket;
    constructor(options?: Partial<SocketOptions>);
    /**
     * Set the given options.
     * Defaults and previous option values will be used if not supplied.
     */
    setOptions(options: Partial<SocketOptions>): void;
    /**
     * Open a new socket connection. By default, the socket will auto
     * connect when creating a new instance.
     */
    connect(): this;
    /**
     * Returns the current state of the socket.
     * @return {State}
     */
    getState(): State;
    /**
     * Close gracefully shuts down the websocket.
     */
    close(): void;
    /**
     * Executes an RPC method on the server. Returns a promise which resolves
     * after it completes, or after a timeout occurs.
     */
    execute(method: string, params?: {
        [key: string]: any;
    }): Promise<any>;
    /**
     * Send emits a packet over the websocket.
     */
    send(packet: Packet): Promise<any>;
    private setState(state);
    private sendPacketInner(packet);
    private extractMessage(packet);
    private rebroadcastEvent(name);
    private schedulePing();
    private handleSocketClose(cause);
}
